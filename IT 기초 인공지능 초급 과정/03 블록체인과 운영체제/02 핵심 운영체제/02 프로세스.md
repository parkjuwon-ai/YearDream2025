# 🖥️ 프로세스 개념 및 관리

## 📌 01. 프로세스의 개념

### ✔️ 프로세스(Process)란?
- **프로세스**: 실행 중인 프로그램. 컴퓨터가 일을 처리하는 **작업 단위**
- **프로그램**: 특정 작업을 수행하는 명령어들의 모음

### ✔️ 프로세스의 구성 요소
- **코드(프로그램)**: 실제 실행할 명령어 집합
- **메모리**: 데이터를 저장하는 기억 공간
- **상태**: 프로세스의 진행 상황

### ✔️ 스레드(Thread)
- **프로세스 안에서 실행되는 흐름의 단위**
- **하나의 프로세스에 하나 이상의 스레드 존재 가능**

### ✔️ 프로그램 vs 프로세스 비교

| 프로그램 | 프로세스 |
|----------|----------|
| 실행 파일 또는 명령어 모음 | 실행 중인 프로그램 (작업 중 상태) |
| 정적인 상태 (메모리에 올라가기 전) | 동적인 상태 (메모리에 올라가 작동 중) |

### ✔️ 프로세스 vs 스레드 비교

| 프로세스 | 스레드 |
|----------|----------|
| 프로그램 실행 단위 | 프로세스 내에서 동작하는 더 작은 작업 단위 |
| 독립적이며 별도 메모리 사용 | 프로세스 내에서 메모리 공유 |
| 프로세스 내에 여러 스레드 존재 가능 | 같은 프로세스 내에서 동시에 여러 작업 수행 가능 |

✅ **프로세스는 독립된 메모리를 할당받고, 스레드는 프로세스가 받은 메모리를 공유한다.**

---

## 📌 02. 프로세스의 구조
✅ **프로세스가 메모리에서 사용하는 구조는 다음과 같음**

| 영역 | 설명 |
|------|------|
| **스택(Stack)** | 임시 데이터(함수 호출, 로컬 변수)가 저장되는 영역 |
| **힙(Heap)** | 코드에서 동적으로 생성되는 데이터가 저장되는 영역 |
| **데이터(Data)** | 전역변수, 정적변수, 배열, 구조체 등이 저장되는 영역 |
| **코드(Code)** | CPU가 실행할 명령어를 저장하는 영역 |

---

### 🔷 코드 영역(Text 영역)
- 프로그램 실행을 위한 명령어가 저장된 공간
- 컴파일된 코드(기계어) 저장
- **읽기 전용(Read-Only)** 영역으로 수정 불가능

### ✔️ 정적 vs 동적
- **정적(static)**: 실행 중 변하지 않음
- **동적(dynamic)**: 실행 중 변할 수 있음

### ✔️ 정적 할당 vs 동적 할당 비교

| 정적 할당 | 동적 할당 |
|-----------|-----------|
| 실행 전에 미리 메모리 할당 | 실행 도중에 메모리 할당 |
| 할당받을 크기가 미리 정해짐 | 크기가 변할 수 있음 |
| 메모리 낭비 발생 가능성 | 필요한 만큼만 메모리 사용 |
| 처리 속도 빠름 | 메모리 할당 과정으로 처리 지연 가능 |

✔ **속도가 중요하다면** → 정적 할당  
✔ **효율적인 메모리 사용이 중요하다면** → 동적 할당  

---

### 🔷 데이터 영역 (Data 영역)
- 프로그램 실행 시 초기화되는 기본 데이터 저장
- 전역변수, 정적변수, 배열, 구조체 등 저장
- 프로그램이 실행되는 동안 유지되는 공간
- **크기는 실행 시점에 고정됨**

---

### 🔷 힙 영역 (Heap 영역)
- **동적으로 생성·소멸되는 데이터 저장 공간**
- 필요할 때마다 새로 만들고 지울 수 있는 영역
- **동적 메모리 할당(`malloc`) 등**에 사용됨
- **사용자가 직접 관리** → 관리 부주의 시 **메모리 누수(memory leak) 발생**
  - **메모리 누수**: 사용이 끝난 메모리를 해제하지 않아 메모리 낭비 및 성능 저하 발생

---

### 🔷 스택 영역 (Stack 영역)
- **함수 호출 및 임시 데이터가 저장되는 공간**
- 함수 호출 시 지역변수, 매개변수 등 임시 데이터가 저장
- **호출이 완료되면 자동으로 소멸됨**
- 크기가 제한되어 있어 과도한 데이터 저장 시 **Stack Overflow 발생**

✅ **스택(Stack)의 특징**
- **후입선출(LIFO: Last-In First-Out)** 방식
- 데이터 추가 → **Push**
- 데이터 제거 → **Pop**

---

✅ **프로세스 실행 흐름** (파이썬 코드 예시)
파이썬 앱 실행 → 프로세스 생성
코드(명령어) 로드
데이터(기본값) 준비
힙과 스택 준비 → 프로그램 실행

---

## 📌 03. 프로세스의 상태

### 🔷 프로세스 상태 전이도
          ┌───────────┐
          │   생성(New)   │
          └───────────┘
                 ↓ 승인
          ┌───────────┐
 ┌───→│ 준비(Ready)   │←─────┐
 │        └───────────┘           │
 │               ↓ CPU 할당          │
 │        ┌───────────┐           │
대기 │←─│ 실행(Running) │─→ 시간 만료
 │        └───────────┘           │
 │                ↓ 이벤트 대기        │
 │        ┌───────────┐           │
 └─── │ 대기(Blocked) │───┘
          └───────────┘
                  ↓ 이벤트 완료
                  │ 준비 상태로 전환
                  ↓ 프로세스 종료
          ┌───────────┐
          │종료(Terminated)│
          └───────────┘





### 🔷 생성(New/Created)
   - 프로세스가 생성된 상태
   - 메모리에 아직 로드되지 않은 상태
   - 준비(Ready) 상태로 가기 위해 대기하는 단계  
   → **리소스 부족 시 오래 대기 가능**

### 🔷 준비(Ready)
   - 메모리에 올라와 있으며, **CPU 실행을 기다리는 상태**
   - 운영체제는 **우선순위에 따라** 준비 상태의 프로세스 중 하나를 선택해 실행(Running) 상태로 전환

### 🔷실행(Running)
   - **CPU를 사용하여 프로세스가 명령어를 처리하는 상태**
   - 일정 시간 이후, CPU 자원을 다른 프로세스에 넘기기 위해 다시 **준비 상태(Ready)로 돌아갈 수 있음**

### 🔷대기(Blocked/Waiting)
   - 프로세스가 특정 작업(**입출력 등**)의 완료를 기다리는 상태
   - 기다리는 작업이 완료되면 다시 **준비(Ready) 상태로 돌아감**

### 🔷종료(Terminated)
   - 프로세스가 모든 작업을 완료한 상태
   - 부모 프로세스가 종료 상태를 확인할 때까지 메모리에 남아있음
   - 확인이 끝나면 **메모리에서 완전히 삭제됨**

---

## 📌 04. 멀티 프로세싱과 멀티 스레딩

| 구분 | 멀티 프로세스 | 멀티 스레드 |
|------|--------------|-------------|
| **설명** | 여러 개의 프로세스를 동시에 실행 | 한 프로세스 내에서 여러 개의 스레드를 동시 실행 |
| **메모리** | 별도의 메모리 사용 | 같은 메모리를 공유 |
| **장점** | 독립성 높아 안정적 | 메모리 공유로 빠르고 효율적 |
| **단점** | 메모리 사용량이 많음 | 하나의 스레드 오류 시 전체 프로세스 중단 가능 |

---

## 📌 05. 프로세스 간 통신 (IPC, Inter-Process Communication)

✅ **프로세스 간 데이터를 주고받는 방법**

| 방식 | 설명 |
|------|------|
| **메시지 큐 (Message Queue)** | 데이터를 큐에 넣고 다른 프로세스가 접근 |
| **공유 메모리 (Shared Memory)** | 프로세스 메모리 일부를 공유 (**빠르지만 충돌 위험**) |
| **파이프 (Pipe)** | 한 방향으로만 데이터 전달 가능 |
| **소켓 (Socket)** | 네트워크 이용 양방향 데이터 전달 |

---

## 📌 06. 프로세스 스케줄링

✅ **프로세스가 여러 개 실행될 때, CPU가 작업 처리 순서를 정하는 방법**

### ✔️ 스케줄링 목적
- **대기 시간 최소화**
- **모든 작업 공평 실행**
- **시스템 전체 성능 향상**

### ✔️ 주요 스케줄링 알고리즘

| 알고리즘 | 설명 | 장점 | 단점 |
|----------|------|------|------|
| **선입선처리 (FIFO)** | 먼저 도착한 프로세스부터 순서대로 처리 | 구현 간단 | 빠른 응답 불가 |
| **최단 작업 우선 (SJF)** | 작업 시간이 가장 짧은 것부터 처리 | 평균 대기시간 최소화 | **기아현상 가능성 있음** |
| **라운드 로빈 (Round Robin)** | 일정 시간마다 프로세스를 번갈아 처리 | 응답시간 짧고 실시간 시스템에 적합 | **전환 오버헤드 발생 가능** |

---

## 📌 07. 교착상태(Deadlock)와 기아상태(Starvation)

### ✔️ 교착상태 (Deadlock)
✅ **서로 필요한 자원을 기다리며 작업이 멈추는 상태**

### ✔️ 교착상태의 발생 조건 (모두 충족 시 교착상태 발생)
1. **상호 배제(Mutual Exclusion)**: 자원을 하나씩만 사용 가능
2. **점유 대기(Hold and Wait)**: 자원을 가진 상태에서 추가 자원을 기다림
3. **비선점(Non-preemption)**: 다른 프로세스의 자원을 강제로 가져올 수 없음
4. **순환 대기(Circular Wait)**: 프로세스들이 순환적으로 자원을 기다림

### ✔️ 교착상태 해결 방법
- **조건 하나라도 해소하면 예방 가능** (ex: 은행원 알고리즘)
- **교착상태 무시 후 재부팅**
- **관련 프로세스 종료**

---

### ✔️ 기아상태 (Starvation)
✅ **우선순위가 낮아 자원을 영원히 받지 못하는 상태**

### ✔️ 기아상태 해결 방법
- **Aging 기법 (오래 기다릴수록 우선순위 증가)**
- **라운드 로빈 방식 적용**
- **선입선처리(FIFO) 방식 적용**
