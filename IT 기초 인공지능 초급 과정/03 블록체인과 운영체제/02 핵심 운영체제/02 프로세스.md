01프로세스의 개념: 특정 작업을 수행하는 명령어들의 모음인 프로그램을 실행되면 프로세스
- 프로세스: 실행 중인 프로그램, 컴퓨터가 일을 처리하는 작업 단위
- 프로그램: 특정 작업을 수행하는 명령어들의 모음

-구성요소
코드(프로그램): 실제 실행할 명령어 집합
메모리: 데이터를 저장하는 기억 공간
상태: 프로세스의 진행 상황

- 스레드
:프로세스 안에서 실행되는 흐름 단위
프로세스에는 하나 이상의 스레드가 존재한다


- 프로그램vs프로세스
프로그램
실행 파일 또는 명령어 모음
정적인 상태 (움직이지 않음)
메모리에 올라가기 전 상태
프로세스
실행 중인 프로그램 (작업 상태)
동적인 상태 (실제 움직이고 작동 중)
메모리 사용
메모리에 올라가서 작업 중

- 프로세스vs스레드
프로세스
프로그램 실행 단위
독립적, 별도의 메모리 사용
하나의 프로세스 내 여러 스레드 존제
쓰레드
 프세스 내에서 동작하는 더 작은 작업 단위
같은 프로세스 내에서 메모리를 공유
프로세스 내에서 동시에 여러작업을 처리
->프로세스는 독립적인 메모리를 할당
->스레드는 프로세스 속에 있는 것이라서 프로세스가 받은 메모리를 공유

02 프로세스의 구조
-프로세스의 구조
--(실행에 필요한 데이터를 저장)
스택 임시 데이터(함수호출, 로컬 변수)이 저장되는 영역
힙 코드에서 동적으로 생성되는 데이터가 저장되는 영역
데이터 전역변수, 정적변수, 배열, 구조체 등이 저장되는 영역
--
코드 CPU에 실행할 명령어를 저장하는 영역


-코드영역
Text영역
컴파일(컴퓨터가 이해할 수 있는 기계어로 변환해주는 것)된 코드가 들어가는 영역으로 읽기 전용 영역
CPU가 실행하게 될 명령어들이 저장됨
>프로그램 실행을 위한 명령어가 저장됨
>읽기 전용(Read-Only) → 코드가 실행되지만 수정할 수 없음

-정적과 동적
정적: (실행 중에)변하지 않는다
동적: (실행 중에)변한다

-정적 활당과 동적 활당
정적활당
실행 전에 미리 메모리를 할당
할당받을 크기가 미리 정해져 있음
할당받고 사용하지 않는 메모리가 발생
실행중에 할당받는 과정이 없기 때문에 속도가 빠름
동적활당
실행 도중에 메모리를 할당
실행 도중에 할당 받을 크기가 변할 수 있음
정확하게 필요한 만큼만 메모리를 사용
추가로 메모릴 할당받는 과정으로 처리가 지연될 수 있음
메모리가 부족한 경우 프로그램이 멈출 수 있음
->동적 할당이 더 좋은가?
항상 그런 건 아님. 
상황에 따라 미리 정해진 공간이 효율적일 수도 있고, 유연하게 바꿀 수 있는 게 효율적일 수도 있음.

-데이터 영역
기본적인 데이터를 저장한 공간
전역 변수와 정적변수들을 위한 공간
프로그램의 시작과 함께 할당되며, 프로그램이 종료되면 소멸
프로그램이 시작되는 시점부터 종료 시점까지 추가되거나 사라지지 않는 공간
>실행시점의 코드와 데이터의 크기는 고정되어 있다

-힙 영역
그때 그때 새로 만들어지거나 없어질 수 있는 데이터를 저장하는 공간
필요하면 만들어서 보관하고 필요 없어지면 다시 지울 수 있는 공간
동적 메모리 할당을 위해 사용되는 메모리 영역
사용자가 직접 관리할 수 있는 메모리 영역
상대적으로 느리며 관리를 잘못할 경우 메모리 누수(동적으로 할당된 메모리를 해제하지 않은 채로 사용하지 않는 상태로 남겨두는 현상 프로그램의 성능 저하와 안정성 문제를 유발)가 발생

-스택 영역
앱이 잠시 필요한 데이터를 올려놓고 사용한 다음, 다시 치우는 임시 공간
잠시 쓰고 사라지는 데이터를 저장하는 곳
함수의 호출과 관련된 지역변수와 매개변수가 저장됨 
함수의 호출과 함께 할당되고, 호출이 완료되면 소멸
프로세스별로 크기가 제한되어 있음

-스택
데이터를 저장하는 선형 자료 구조
자료를 넣는 것을 push라고 하고 빼는 것을 pop
후입선출(Last-In First-Out)방식

파이썬 코드가 프로세스로 실행될 때의 흐름
파이썬 앱 실행 → 프로세스 생성 →
- 코드(명령어) 로드
- 데이터(기본값) 준비
- 힙과 스택 준비
→ 프로그램 실행

03 프로세스의 상태
-프로세스 상태 전이도
**GPT그려줘

-생성(New/Created)
프로세스가 만들어졌으나 아직 메모리에 완전히 올라가지 않은 상태
준비(Ready) 상태로의 승인을 기다리는 단계
아직 메모리에 로드되지 않은 상태
대부분 바로 준비상태로 승인되지만, 리소스가 부족하면 이 상태에서 오래 대기할 수 있음

-준비(Ready)
메모리에 올라왔으며 CPU가 작업을 수행할 준비가 된 상태
프로세스가 CPU를 사용하고 있지 않지만, 언제든 실행 될 수 있도록 대기하는 상태
운영체제는 우선순위가 높은 순서대로 CPU를 할당해서 실행(Running)상태로 전이함

-실행(Running)
CPU가 할당되어 프로세스의 명령어들을 처리해주는 단계
동시에 다른 프로세스들을 처리하기 위해서 일정시간 이후 다시 준비(Ready)상태로 전이함

-대기(Blocked/Waiting)
프로세스가 특정 작업(자원 또는 이벤트)이 완료되기를 기다리는 상태
입출력 완료 등 특정 이벤트를 기다리는 상태
이벤트가 완료되면 다시 준비(Ready)상태로 돌아감

-종료(Terminated)
모든 명령어가 완료된 상태
부모 프로세스가 상태를 확인하기 위해 바로 삭제되지 않고 이 상태에서 대기
이 상태가 끝나면 프로세스가 메모리에서 삭제됨


 
05 프로세스 스케줄링
컴퓨터에서 여러작업이 실행될 때, CPU가 어떤 작업을 먼저 처리할지 정하는 방법

대기시간은 가능한 최소화
가능한 공평하게 프로세를 처리하는 것이 목적

스케줄링의 목적
-대기 시간을 최소화
-모든 작업이 공평하게 실행되도록 함
-시스템 전체의 성능을 높임

스케줄리의 종류
선입선처리
최단 작업 우선
라운드 로빈


-선입선처리
가장 먼저 도착한 프로세스부터 순서대로 처리하는 방법
구현이 간단하고 일괄처리에 효과적인 방법
빠른 응답을 요구하는 환경에서는 부적합

-최단 작업 우선
평균 대기시간을 최소로 만들기 위한 알고리즘
작업이 얼마나 걸리는지 예측하기 어려움
오래 걸리는 작업은 매번 양보하면서 평생 처리가 완료되지 않을 수 있음(기아 현상 발생)

-라운드 로빈
모든 작업이 일정한 시간 동안 번갈아 가며 실행되는 방식
일정 시간을 정해두고 시간이 지나면 대기열의 맨 뒤로 보내고 다음 작업을 처리
응답시간이 짧아지는 장점이 있어 실시간 시스템에 유리
프로세스 간의 전환이 많아지는 단점이 있음(오버헤드)


04 멀티 프로세싱
-멀티 프로세싱
여러개의 프로세스를 돌아가면서 조금씩 처리
하나의 컴퓨터가 여러 개의 프로세스를 동시에 처리하는 방식을 의미
동시에 여러 작업을 수행
하나의 CPU가 여러 작업을 빠르게 번갈아 처리하거나, 여러 CPU가 각 작업을 나누어 처리합니다.

-멀티 스레드
한 프로세스 내에서 자원을 공유하면서 여러작업을 처리
새로 프로세스를 생성하고 리소스를 할당받는 과정이 없어서 더 빠르게 처리가 가능
하나의 스레드가 문제가 생기면 프로세스 전체가 종료될 수 있음

멀티 프로세싱 vs 멀티 스레딩
멀티 프로세스(Multi Process)
여러 개의 독립된 프로세스가 동시에 실행
각 프로세스는 별도의 메모리 공간과 리소스를 할당받아 독립적으로 작업 처리
여러 집에서 각자 독립적으로 집안일을 수행하는 것과 유사합니다.
장점: 한 프로세스의 오류가 다른 프로세스에 영향을 주지 않아 안정성이 높습니다.
단점: 프로세스 간 자원 공유가 어렵고, 메모리 사용량이 많아질 수 있습니다.
멀티 스레드(Multi Thread)
한 프로세스 내에서 여러 개의 스레드가 작업을 동시에 처리
 스레드 간 메모리와 자원을 공유하며 작업
 한 집 안에서 여러 사람이 각자의 일을 분담하는 것과 유사합니다.
장점: 메모리와 리소스 공유로 처리 속도가 빠르고 효율적입니다.
단점: 한 스레드에서 문제가 발생하면 전체 프로세스가 중단될 위험이 존재합니다.

-프로세스간 통신(IPC,Inter-Process Communication)
컴퓨터에서 실행되는 여러 프로그램(프로세스)이 서로 데이터를 주고받는 방법
다른 프로세스의 리소스는 절대 침범하면 안됨
운영체제가 허용하는 방법내에서 데이터를 주고 받는 방법들

-프로세스 간 통신
메시지 큐
데이터를 넣어두고 다른 프로세스들이 사용할 수 있게 하는 방법
공유 메모리
프로세스의 메모리 일부를 공유 메모리로 만들어 다른 프로세스와 공유하는 방법
파이프 (Pipe)
한 방향으로만 데이터 전달 가능
소켓 
소켓을 생성하여 다른 양방향 통신을 통해 데이터를 전달

-메시지 큐
운영체제에서 관리하는 메시지 큐를 통해 통신하는 방법 
데이터를 메시지 큐에 넣어두면 다른 프로세스가 데이터를 찾아서 다룰 수 있음

-공유메모리
프로세스의 메모리 일부를 공유 메모리로 만들어 다른 프로세스와 공유
데이터를 복사하는 과정들이 생략되어 상대적으로 빠르게 동작
리소스를 공유하기 때문에 충돌할 위험이 있음

-소켓 
다른 네트워크에 있는 프로세스와도 통신할 수 있는 소켓 통신을 이용
통신 규약에 따라 통신하며, 데이터를 주고 받는 양방향 통신

05 프로세스 스케줄링
컴퓨터에서 여러작업이 실행될 때, CPU가 어떤 작업을 먼저 처리할지 정하는 방법

대기시간은 가능한 최소화
가능한 공평하게 프로세를 처리하는 것이 목적

스케줄링의 목적
-대기 시간을 최소화
-모든 작업이 공평하게 실행되도록 함
-시스템 전체의 성능을 높임

스케줄리의 종류
선입선처리
최단 작업 우선
라운드 로빈


-선입선처리
가장 먼저 도착한 프로세스부터 순서대로 처리하는 방법
구현이 간단하고 일괄처리에 효과적인 방법
빠른 응답을 요구하는 환경에서는 부적합

-최단 작업 우선
평균 대기시간을 최소로 만들기 위한 알고리즘
작업이 얼마나 걸리는지 예측하기 어려움
오래 걸리는 작업은 매번 양보하면서 평생 처리가 완료되지 않을 수 있음(기아 현상 발생)

-라운드 로빈
모든 작업이 일정한 시간 동안 번갈아 가며 실행되는 방식
일정 시간을 정해두고 시간이 지나면 대기열의 맨 뒤로 보내고 다음 작업을 처리
응답시간이 짧아지는 장점이 있어 실시간 시스템에 유리
프로세스 간의 전환이 많아지는 단점이 있음(오버헤드)


06 교착상태와 기아상태
컴퓨터에서 여러작업이 실행될 때 서로 필요한 자원을 차지하거나 빼앗지 못해서 진행이 멈추는 현상

-교착상태
프로세스가 서로 상대방의 작업이 끝나기 만을 기다리고 있는 상태
결과적으로 아무것도 완료되지 않음

-교착상태 발생 조건
모두 만족해야함
상호 배제 자원을 동시에 둘 이상이 사용할 수 없다
점유대기 자원을 이미 가진 상태에서 다른 자원을 사용하려고 기다린다
비선점 다른 프로세스가 자원을 뺏어올 방법이 없다
순환대기 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다

-교착상태의 해결
은행원 알고리즘
자원을 할당받기 전에 운영체제가 검사를 하고 할당해준다
교착상태 무시
아무것도 하지 않는다
프로세스 종료
교착상태가 발견되면 해당 관련 프로세스를 종료시켜서 해결한다

-기아상태
프로세스의 우선순위가 낮아서 원하는 자원을 계속 받지 못하는 상태

- 기아상태의 해결방법
우선순위 조정 (Aging 기법)
오래 기다린 프로세스의 우선순위를 점점 높여줌

라운드 로빈 방식 사용
모든 프로세스가 일정한 시간 동안 CPU를 사용할 수 있도록 함

FIFO(선입선처리) 방식 적용
먼저 요청한 프로세스부터 처리

